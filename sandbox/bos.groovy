import oracle.odi.domain.project.finder.IOdiProjectFinder
import oracle.odi.domain.model.finder.IOdiDataStoreFinder
import oracle.odi.domain.model.finder.IOdiModelFinder
import oracle.odi.domain.model.OdiModel
import oracle.odi.domain.model.OdiColumn
import oracle.odi.domain.project.finder.IOdiFolderFinder
import oracle.odi.domain.project.finder.IOdiKMFinder
import oracle.odi.domain.mapping.finder.IMappingFinder
import oracle.odi.domain.adapter.project.IKnowledgeModule.ProcessingType
import oracle.odi.domain.model.OdiDataStore
import oracle.odi.core.persistence.transaction.support.DefaultTransactionDefinition
import oracle.odi.generation.support.OdiScenarioGeneratorImpl;
import oracle.odi.generation.IOdiScenarioGenerator;
import java.util.List

// Helper function - performs column mappings
def createExp(comp, tgtTable, propertyName, expressionText) {
    DatastoreComponent.findAttributeForColumn(comp,tgtTable.getColumn(propertyName)).setExpressionText(expressionText)
}
// Function to delete a given mapping - currently not called in main code
def removeMapping(folder, map_name) {
    txnDef = new DefaultTransactionDefinition()
    tm = odiInstance.getTransactionManager()
    tme = odiInstance.getTransactionalEntityManager()
    txnStatus = tm.getTransaction(txnDef)
    try {
        Mapping map = ((IMappingFinder) tme.getFinder(Mapping.class)).findByName(folder, map_name)
        if (map != null) {
            odiInstance.getTransactionalEntityManager().remove(map);
        }
    } catch (Exception e) {e.printStackTrace();}
    tm.commit(txnStatus)
}

// Find a folder within a project
def find_folder(project_code, folder_name) {
    txnDef = new DefaultTransactionDefinition()
    tm = odiInstance.getTransactionManager()
    tme = odiInstance.getTransactionalEntityManager()
    txnStatus = tm.getTransaction(txnDef)
    pf = (IOdiProjectFinder)tme.getFinder(OdiProject.class)
    ff = (IOdiFolderFinder)tme.getFinder(OdiFolder.class)
    project = pf.findByCode(project_code)
    if (project == null) {
        project = new OdiProject(project_code, project_code)
        tme.persist(project)
    }
    folderColl = ff.findByName(folder_name, project_code)
    OdiFolder folder = null
    if (folderColl.size() == 1)
        folder = folderColl.iterator().next()
    if (folder == null) {
        folder = new OdiFolder(project, folder_name)
        tme.persist(folder)
    }
    tm.commit(txnStatus)
    return folder
}

// Main method for creating mappings
// Arguments are:
// -- folder name
// -- mapping name
// -- source schema name (logical)
// -- source table name
// -- target schema name (logical)
// -- target table name
// -- staging-to-foundation flag - a batch_id filter is added to the mapping if true
// -- truncate target flag - the associated KM option is set accordingly
// -- release tag - used in the object descriptions
def basic_mapping(fold, myMap, srcSchema, srcTable, tgtSchema, tgtTable, Boolean addFilter, Boolean truncTgt, relTag) {
    folder = find_folder("RM_PROJECT",fold)
    //removeMapping(folder, myMap)

    // transaction handling
    txnDef = new DefaultTransactionDefinition()
    tm = odiInstance.getTransactionManager()
    tme = odiInstance.getTransactionalEntityManager()
    txnStatus = tm.getTransaction(txnDef)

    // create datastore finder instance
    dsf = (IOdiDataStoreFinder)tme.getFinder(OdiDataStore.class)

    // create new mapping
    map = new Mapping(myMap, folder)
    tme.persist(map)


    // create object description (including release tag)
    currDate = new Date()
    String mapDesc = "Mapping to load from " + srcTable + " to " + tgtTable + ". Generated by Groovy script on " + currDate.getDateString() + ". Release: " + relTag
    map.setDescription(mapDesc)


    // add existng datastores to mapping
    boundTo_emp = dsf.findByName(srcTable, srcSchema)
    comp_emp = new DatastoreComponent(map, boundTo_emp)
    boundTo_tgtemp = dsf.findByName(tgtTable, tgtSchema)
    comp_tgtemp = new DatastoreComponent(map, boundTo_tgtemp)
    comp_emp.connectTo(comp_tgtemp)


    // loop through target columns, connecting to appropriate source columns
    targ_atts = comp_emp.getAttributes()
    for (MapAttribute targ_att : targ_atts ) {
        from_col = comp_emp.getName() + "." + targ_att.getName()
        to_col = targ_att.getName()
        createExp(comp_tgtemp, boundTo_tgtemp, to_col, from_col)
    }

    // get deployment specs and physical nodes...
    deploymentspec = map.getDeploymentSpec(0)
    node = deploymentspec.findNode(comp_tgtemp)
    aps = deploymentspec.getAllAPNodes() // APs have LKMs assigned
    tgts = deploymentspec.getTargetNodes() // Target Nodes have IKMs assigned
    println deploymentspec.getExecutionUnits()
    // ...then find the IKM we want to use and configure the physical target
    ikmf = (IOdiKMFinder)tme.getFinder(OdiIKM.class)
    ins_ikm = ikmf.findByName("IKM SQL Control Append");
    def tgt = tgts.iterator()
    def tgt_node = tgt.next()
    // optionally set the target to truncate
    tgt_node.setIKM(ins_ikm)

    lkmf = (IOdiKMFinder)tme.getFinder(OdiLKM.class)
    ins_lkm = lkmf.findByName("LKM SQL to Oracle" );
    ap = aps.iterator()
    def ap_node = ap.next()
    // optionally set the target to truncate
    ap_node.setLKM(ins_lkm)

    if(truncTgt == true){
        tgt_node.getOptionValue(ProcessingType.TARGET,"TRUNCATE").setValue("true")
    }
    // disable flow control and vacuuming
    tgt_node.getOptionValue(ProcessingType.TARGET,"FLOW_CONTROL").setValue("false")
    tme.persist(map)
    println("Created mapping " + myMap)

    // generate scenario and set description
    IOdiScenarioGenerator scenarioGenerator = new OdiScenarioGeneratorImpl(odiInstance)
    scenName = "LOAD_" + tgtTable.toUpperCase() + "_01"
    println("scenName = " + scenName)
    myScen = scenarioGenerator.generateScenario(map, scenName ,"001")
    myScen.setDescription(mapDesc)

    tm.commit(txnStatus)
    println("Created scenario " + scenName)
    return map
}

// method to call basic_mapping() with landing-to-staging-specific params
def source_to_staging_mapping(tableName, relTag){
    mappingName = "Load." + tableName.toUpperCase() + "_STG.01"
    srcTable = tableName
    map = basic_mapping("Credit",mappingName,"ORACLE_TST",srcTable,"ORACLE_ODI",tableName,false,true, relTag)
    return map
}


// USAGE

// define release tag to be used in object descriptions
releaseTag = "REL:V_1.0"

// specify file location
mappingFileName = "/u01/app/more/mappings.csv"

// loop through file, creating mappings
new File(mappingFileName).eachLine { line ->
    source_to_staging_mapping(line, releaseTag)

}
